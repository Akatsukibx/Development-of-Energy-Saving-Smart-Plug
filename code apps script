/************* CONFIG *************/
// ค่าคงที่: ตั้งชื่อชีต, รหัสลับสำหรับตรวจสอบสิทธิ์ (EXPECTED), และโซนเวลา
const DATA_SHEET    = 'Data';
const LOG_SHEET     = 'Log';
const SUMMARY_SHEET = 'Summary';
const EXPECTED      = 'Smart_Plug';
const TZ            = 'Asia/Bangkok';

/************* Entrypoints *************/
// จุดเข้า Web App: Google จะเรียก doPost/doGet ตามชนิดคำขอ HTTP
// ทั้งสองฟังก์ชันโยนงานไปที่ handleReq_ พร้อมระบุ method
function doPost(e){ return handleReq_(e, 'POST'); }
function doGet(e){  return handleReq_(e, 'GET');  }

/************* Main *************/
// ตัวควบคุมหลักของระบบ: เตรียมชีต, parse payload, ตรวจ secret, route การทำงาน,
// เขียนข้อมูลลง Data/Summary, และส่งผลลัพธ์กลับ
function handleReq_(e, method){
  // เปิดสเปรดชีตและเตรียมชีตย่อย (สร้างใหม่ถ้าไม่พบ)
  const ss     = SpreadsheetApp.getActive();
  const dataSh = ss.getSheetByName(DATA_SHEET)    || ss.insertSheet(DATA_SHEET);
  const sumSh  = ss.getSheetByName(SUMMARY_SHEET) || ss.insertSheet(SUMMARY_SHEET);
  const logSh  = ss.getSheetByName(LOG_SHEET)     || ss.insertSheet(LOG_SHEET);

  // ให้แน่ใจว่ามีหัวคอลัมน์ครบถ้วนในแต่ละชีต
  ensureDataHeader_(dataSh);
  ensureSummaryHeader_(sumSh);
  ensureLogHeader_(logSh);

  // --- Parse payload ---
  // รองรับทั้ง JSON body, query parameter (e.parameter), และ raw/plain (CSV หรือ a=b&c=d)
  const safe    = e || {};
  const headers = safe.headers || {};
  const ctHdr   = String(headers['content-type'] || headers['Content-Type'] || (safe.postData && safe.postData.type) || '').toLowerCase();
  const raw     = (safe.postData && safe.postData.contents) || '';
  let d = {};
  try {
    // 1) พยายาม parse JSON
    try { d = JSON.parse(raw || '{}'); } catch (_) {}
    // 2) ถ้าไม่ได้และมีพารามิเตอร์ → ใช้ e.parameter
    if (!Object.keys(d).length && safe.parameter && Object.keys(safe.parameter).length) d = safe.parameter;
    // 3) ถ้ายังไม่ได้และมี raw → parse แบบ plain (CSV หรือ a=b)
    if (!Object.keys(d).length && raw) d = parsePlain_(raw);
  } catch (err) {
    // parse ไม่สำเร็จ → บันทึก log แล้วตอบ BAD_PAYLOAD
    log_(logSh, method, 'parse-error', String(err), raw);
    return txt_('BAD_PAYLOAD');
  }

  // --- Auth ---
  // ตรวจรหัสลับจาก Header (X-Secret) หรือฟิลด์ k/K ใน body/parameter แล้วเทียบกับ EXPECTED
  const secret = headers['x-secret'] || headers['X-Secret'] || (d.k || d.K) ||
                 (safe.parameter && (safe.parameter.k || safe.parameter.K)) || '';
  const ok = EXPECTED ? (secret === EXPECTED) : true;
  // log บันทึกชนิด content-type + สถานะ secret (ok/bad) + ตัวอย่าง payload
  log_(logSh, method, 'ct='+ctHdr, 'secret='+(ok?'ok':'bad'), raw || JSON.stringify(d));
  if (!ok) return txt_('FORBIDDEN'); // ไม่ผ่านสิทธิ์

  // พารามิเตอร์ควบคุม route เช่น pull_state, peak_today, weekly, monthly ฯลฯ
  const ctParam = String((d.ct || (safe.parameter && safe.parameter.ct) || '')).trim().toLowerCase();

  /************* READ-ONLY ROUTES *************/
  // ดึงสถานะล่าสุดที่ "มีความหมาย" (กันกรณีเพิ่งรีเซ็ตแล้วค่าปัจจุบันเป็น 0)
  if (ctParam === 'pull_state' || ctParam === 'last') {
    const latest = latestFromData_(dataSh);
    return json_(latest || { ok:false, reason:'NO_DATA' });
  }

  // หาช่วงเวลา peak ของ "วันนี้" ด้วยหน้าต่าง 30 นาที (คำนวณจาก Data)
  if (ctParam === 'peak_today') {
    const res = peakTodayWindowFromData_(dataSh, 30);
    return json_(res);
  }

  // หาช่วง peak ตามวันระบุ (ymd=YYYYMMDD) ใช้หน้าต่าง 30 นาที
  if (ctParam === 'peak_by_ymd') {
    const ymd = String(d.ymd || (safe.parameter && safe.parameter.ymd) || '');
    const res = peakWindowByYmd_(dataSh, ymd, 30);
    return json_(res);
  }

  // Trigger สรุปรายสัปดาห์/รายเดือน: ให้ชีต Summary เป็นแหล่งข้อมูล แล้วคำนวณรวม N วันล่าสุดเทียบ N วันก่อน
  if (ctParam === 'weekly') {
    const wk = computeWeeklySummaryFromSheet_(sumSh);
    // บันทึกข้อความสรุปและตัวเลขสำคัญลง Log
    log_(logSh, 'WEEKLY_AUTO', wk.text, JSON.stringify({ thisWh:wk.thisWh, prevWh:wk.prevWh, days:wk.days }));
    return json_(wk);
  }
  if (ctParam === 'monthly') {
    const mo = computeMonthlySummaryFromSheet_(sumSh);
    log_(logSh, 'MONTHLY_AUTO', mo.text, JSON.stringify({ thisWh:mo.thisWh, prevWh:mo.prevWh, days:mo.days }));
    return json_(mo);
  }

  /************* WRITE DATA (live telemetry) *************/
  // หากไม่ได้เรียกเส้นทาง read-only ด้านบน → ถือว่าเป็นการ "ส่งเทเลเมทรี" ปกติ
  const now   = new Date();
  const ymd   = Utilities.formatDate(now, TZ, 'yyyy-MM-dd');

  // รวมค่า peak ของ "วันนี้": พิจารณา (1) ค่าที่อยู่ในชีตล่าสุด, (2) peak ที่ส่งมา, (3) dWh ปัจจุบัน
  const prevPeakToday = readLastPeakToday_(dataSh, ymd);
  const dWhNow        = num_(d.dWh) || 0;
  const incomingPeak  = Number(d.peakdailyWh || 0);
  const peakToday     = Math.max(dWhNow, incomingPeak, prevPeakToday);

  // บันทึก 1 แถวลง Data ตามลำดับคอลัมน์หัวตาราง (อ่านง่ายและครบถ้วน)
  const row = [
    now,
    onoff_(d.swA), onoff_(d.swB),
    num_(d.iIn), num_(d.vIn),
    num_(d.vA), num_(d.vB),
    num_(d.iA), num_(d.iB),
    num_(d.pA), num_(d.pB),
    num_(d.tC), num_(d.hum),
    tripText_(d.tripA), tripText_(d.tripB),
    num_(d.dWh), num_(d.wWh),
    num_(d.dWhPrev), num_(d.wWhPrev),
    num_(d.mWh), num_(d.mWhPrev),
    peakToday
  ];
  dataSh.appendRow(row);
  SpreadsheetApp.flush(); // ยืนยันการเขียน

  // บันทึก Summary เฉพาะตอน "ตัดรอบรายวัน" (วันละ 1 แถว) และใส่ค่า peak ของวัน
  appendSummary_ON_CUT_ONLY_(sumSh, d, dataSh);

  // (optional) ถ้า payload ใส่ ct=summary → เก็บข้อความสรุป/คำแนะนำใน Log
  if (String(d.ct || '') === 'summary') {
    log_(logSh, 'SUMMARY', d.dailySummary || '', d.adviceSummary || '');
  }

  // ส่งสัญญาณสำเร็จกลับไปยังผู้เรียก
  return txt_('OK');
}

/************* Headers *************/
// สร้าง/เติมหัวคอลัมน์ของชีต Data ให้ครบตามลำดับ (ถ้ายังไม่มี)
function ensureDataHeader_(sh){
  const want = [
    'ts','swA','swB','iIn','vIn','vA','vB','iA','iB','pA','pB',
    'tC','hum','tripA','tripB',
    'dailyWh','weeklyWh','dailyWhPrev','weeklyWhPrev','monthWh','monthWhPrev',
    'peakdailyWh' // V
  ];
  if (sh.getLastRow() === 0){
    sh.appendRow(want);
  } else {
    const header = sh.getRange(1,1,1,sh.getMaxColumns()).getValues()[0].map(x=>String(x||'').trim());
    if (header.length < want.length){
      sh.getRange(1, header.length+1, 1, want.length-header.length)
        .setValues([want.slice(header.length)]);
    }
  }
}
// สร้าง/เติมหัวคอลัมน์ของชีต Summary: เก็บค่าใช้ไฟวันละแถว + peak และ tips
function ensureSummaryHeader_(sh){
  // A..J = ts, dailyWh, dailyWhPrev, weeklyWh, weeklyWhPrev, monthWh, monthWhPrev, peakdailyWh, peakmonthWh, tips
  const want = ['ts','dailyWh','dailyWhPrev','weeklyWh','weeklyWhPrev','monthWh','monthWhPrev','peakdailyWh','peakmonthWh','tips'];
  if (sh.getLastRow() === 0){
    sh.appendRow(want);
    return;
  }
  const header = sh.getRange(1,1,1,sh.getMaxColumns()).getValues()[0].map(x=>String(x||'').trim());
  if (header.length < want.length){
    sh.getRange(1, header.length+1, 1, want.length-header.length).setValues([want.slice(header.length)]);
  }
}
// สร้างหัวคอลัมน์ของชีต Log: ใช้บันทึกเหตุการณ์สำคัญ/ข้อผิดพลาด
function ensureLogHeader_(sh){
  if (sh.getLastRow() === 0){
    sh.appendRow(['ts','method','tag','info']);
  }
}

/************* Summary writer (daily cut only) *************/
// เขียนแถวสรุปลง Summary เฉพาะตอน "ตัดรอบวัน": dWh≈0 และ dWhPrev>0
function appendSummary_ON_CUT_ONLY_(sh, d, dataSh){
  const near0 = v => Math.abs(Number(v)||0) < 1e-6;

  // ค่า ณ ขณะนี้กับค่า Prev ที่แนบมาจากอุปกรณ์
  const dWh      = Number(d.dWh)||0;
  const dWhPrev  = Number(d.dWhPrev||0);
  const wWh      = Number(d.wWh)||0;
  const wWhPrev  = Number(d.wWhPrev)||0;
  const mWh      = Number(d.mWh)||0;
  const mWhPrev  = Number(d.mWhPrev)||0;

  // เงื่อนไข "ตัดรอบวัน": dWh ใกล้ 0 และ dWhPrev มีค่า → เพิ่งรีเซ็ตวันใหม่
  const isCut = ( near0(dWh) && !near0(dWhPrev) );
  if (!isCut) return;

  // เลือกค่าที่จะบันทึกลง Summary ของวันนั้น
  const dailyEff   = dWhPrev;
  const weeklyEff  = !near0(wWh) ? wWh : ( !near0(wWhPrev) ? wWhPrev : dWhPrev );
  const monthlyEff = !near0(mWh) ? mWh : ( !near0(mWhPrev) ? mWhPrev : 0 );

  // วันที่ปัจจุบัน + คำนวณ peak รายวันจากชีต Data (รวมค่าที่บันทึกก่อนหน้า)
  const now  = new Date();
  const ymd  = Utilities.formatDate(now, TZ, 'yyyy-MM-dd');
  const peakD = calcPeakDailyForYmd_(dataSh, ymd);
  const peakM = Number(d.peakmonthWh || 0); // รองรับการใช้งานอนาคต

  // ถ้าวันนี้มีแถวอยู่แล้ว → อัปเดตทับ, ถ้ายังไม่มี → เพิ่มใหม่
  const map = { ts:1 };
  const rowIndex = getSummaryRowIndex_(sh, ymd, map);
  if (rowIndex > 0){
    sh.getRange(rowIndex, 2, 1, 6).setValues([[dailyEff, dWhPrev, weeklyEff, wWhPrev, monthlyEff, mWhPrev]]);
    sh.getRange(rowIndex, 8, 1, 2).setValues([[peakD, peakM]]);
    sh.getRange(rowIndex, 10).setValue(String(d.adviceSummary || '')); // tips
    return;
  }

  // เพิ่มแถวใหม่สำหรับวันนี้
  sh.appendRow([ymd, dailyEff, dWhPrev, weeklyEff, wWhPrev, monthlyEff, mWhPrev, peakD, peakM, String(d.adviceSummary || '')]);
}

/************* Peak helpers *************/
// อ่านค่า peakdailyWh ของ "แถวล่าสุด" หากยังเป็นวันเดียวกัน; ไม่ใช่วันเดียวกันให้ 0
function readLastPeakToday_(sh, ymdStr){
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return 0;
  const lastTs = sh.getRange(lastRow, 1).getValue();
  const lastYmd = cellToYmd_(lastTs);
  if (lastYmd !== ymdStr) return 0;
  const lastPeak = Number(sh.getRange(lastRow, 22).getValue() || 0); // คอลัมน์ที่ 22 = peakdailyWh
  return lastPeak || 0;
}
// คำนวณค่า peak สูงสุดของวัน ymd จากทั้งคอลัมน์ dailyWh และ peakdailyWh
function calcPeakDailyForYmd_(dataSh, ymdStr){
  const lastRow = dataSh.getLastRow();
  if (lastRow < 2) return 0;
  const tsCol = dataSh.getRange(2, 1,  lastRow-1, 1).getValues(); // ts
  const pCol  = dataSh.getRange(2, 16, lastRow-1, 1).getValues(); // dailyWh (คอลัมน์ที่ 16)
  const vCol  = dataSh.getRange(2, 22, lastRow-1, 1).getValues(); // peakdailyWh (คอลัมน์ที่ 22)
  let peak = 0;
  // ไล่หา max จาก dailyWh ของวันนั้น
  for (let i=0;i<tsCol.length;i++){
    const ymd = cellToYmd_(tsCol[i][0]);
    if (ymd === ymdStr){
      const dwh = Number(pCol[i][0] || 0);
      if (dwh > peak) peak = dwh;
    }
  }
  // ไล่หา max จาก peakdailyWh ที่เคยบันทึกไว้
  for (let i=0;i<tsCol.length;i++){
    const ymd = cellToYmd_(tsCol[i][0]);
    if (ymd === ymdStr){
      const v = Number(vCol[i][0] || 0);
      if (v > peak) peak = v;
    }
  }
  return peak;
}

/************* Peak window (today/by ymd) *************/
// คำนวณ "ช่วงเวลาพีค" ของวันนี้ ด้วยหน้าต่าง WMIN นาที (default 30)
// สร้างชุดข้อมูลต่อนาทีจากกราฟ dWh สะสม แล้วหา subwindow ที่ผลรวมเพิ่มขึ้นสูงสุด
function peakTodayWindowFromData_(sh, windowMin){
  const WMIN = windowMin || 30;
  const now  = new Date();
  const todayY = Utilities.formatDate(now, TZ, 'yyyy-MM-dd');

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return { ok:false, reason:'NO_DATA' };

  const tsCol = sh.getRange(2, 1,  lastRow-1, 1).getValues(); // ts
  const dCol  = sh.getRange(2, 16, lastRow-1, 1).getValues(); // dailyWh

  const rows = [];
  for (let i=0;i<tsCol.length;i++){
    const ts = tsCol[i][0];
    if (!ts) continue;
    const ymd = cellToYmd_(ts);
    if (ymd === todayY){
      const t   = (ts instanceof Date) ? ts : new Date(ts);
      const dwh = Number(dCol[i][0] || 0);
      rows.push({ t, dwh });
    }
  }
  return peakWindowFromRows_(rows, WMIN);
}
// คำนวณ "ช่วงเวลาพีค" สำหรับวัน ymd ที่ระบุ
function peakWindowByYmd_(sh, ymdStr, windowMin){
  const WMIN = windowMin || 30;

  const lastRow = sh.getLastRow();
  if (lastRow < 2) return { ok:false, reason:'NO_DATA' };

  const tsCol = sh.getRange(2, 1,  lastRow-1, 1).getValues();
  const dCol  = sh.getRange(2, 16, lastRow-1, 1).getValues();

  const rows = [];
  for (let i=0;i<tsCol.length;i++){
    const ts = tsCol[i][0];
    if (!ts) continue;
    const ymd = cellToYmd_(ts);
    if (String(ymd) === String(ymdStr)){
      const t   = (ts instanceof Date) ? ts : new Date(ts);
      const dwh = Number(dCol[i][0] || 0);
      rows.push({ t, dwh });
    }
  }
  return peakWindowFromRows_(rows, WMIN);
}
// อัลกอริทึมสไลด์วินโดว์: แตกข้อมูลเป็นรายนาทีจากความต่างของ dWh ระหว่างจุดติดกัน
// แล้วสไลด์หน้าต่าง WMIN นาทีเพื่อหาผลรวมการเพิ่มขึ้นสูงสุด (avgWh = ผลรวมในหน้าต่าง)
function peakWindowFromRows_(rows, WMIN){
  if (rows.length < 2) return { ok:false, reason:'NOT_ENOUGH' };
  // แตกเป็น “นาที” + ปริมาณพลังงานเพิ่มขึ้นต่อหนึ่งนาที
  const mins = [];
  for (let i=1;i<rows.length;i++){
    const prev = rows[i-1], cur = rows[i];
    let inc = cur.dwh - prev.dwh; if (inc < 0) inc = 0; // ป้องกันกรณีรีเซ็ต
    const dtMin = Math.max(1, Math.round((cur.t - prev.t)/60000)); // จำนวน "นาที" ระหว่างสองจุด
    const perMin = inc / dtMin; // เฉลี่ยต่อ 1 นาที
    for (let k=0;k<dtMin;k++){
      mins.push({ t: new Date(prev.t.getTime() + (k+1)*60000), inc: perMin });
    }
  }
  if (!mins.length) return { ok:false, reason:'NO_MIN_SAMPLES' };

  // สไลด์วินโดว์เพื่อหาผลรวม inc สูงสุดภายในช่วงเวลา WMIN นาที
  let bestSum = 0, bestStart = mins[0].t;
  let sum = 0, L = 0;
  for (let R=0; R<mins.length; R++){
    sum += mins[R].inc;
    // บีบหน้าต่างให้ความยาว < WMIN นาทีเสมอ
    while ((mins[R].t - mins[L].t) >= WMIN*60000){
      sum -= mins[L].inc; L++;
    }
    if (sum > bestSum){
      bestSum  = sum;
      bestStart = new Date(mins[R].t.getTime() - (WMIN-1)*60000);
    }
  }
  const startStr = Utilities.formatDate(bestStart, TZ, 'HH:mm');
  const endStr   = Utilities.formatDate(new Date(bestStart.getTime()+WMIN*60000), TZ, 'HH:mm');
  return { ok:true, start:startStr, end:endStr, avgWh: Math.round(bestSum*100)/100 };
}

/************* Weekly/Monthly calculators (sheet-driven) *************/
// ผู้ช่วยรวมค่า N วันล่าสุดเทียบ N วันก่อนหน้า จากชีต Summary (ใช้คอลัมน์ dailyWh)
function sumWithPrevDays_(sumSh, N){
  const lastRow = sumSh.getLastRow();
  if (lastRow < 2) return { thisSum:0, prevSum:0, count:0 };
  // อ่านคอลัมน์ B: dailyWh ย้อนหลัง 2N แถวล่าสุด
  const take = Math.min(2*N, lastRow - 1);
  const vals = sumSh.getRange(lastRow - take + 1, 2, take, 1).getValues();
  const arr  = vals.map(r => Number(r[0] || 0));
  const thisSlice = arr.slice(-N);
  const prevSlice = arr.slice(-2*N, -N);
  const sum = a => a.reduce((s,x)=>s+(Number(x)||0), 0);
  return { thisSum: sum(thisSlice), prevSum: sum(prevSlice), count: thisSlice.length };
}
// แปลง Wh → “หน่วย” (kWh) พร้อมทศนิยม digits
function makeThaiUnits_(wh, digits){ return ((Number(wh)||0)/1000).toFixed(digits) + ' หน่วย'; }
// สร้างข้อความเปอร์เซ็นต์เพิ่มขึ้น/ลดลง เทียบช่วงก่อน
function fmtPct_(cur, prev){
  if (!prev || prev <= 0) return '0% (ช่วงแรก)';
  const pct = Math.round(Math.abs((cur - prev)/prev)*100);
  return (cur >= prev ? 'เพิ่มขึ้น ' : 'ลดลง ') + pct + '%';
}
// สรุปค่าใช้ไฟรายสัปดาห์ (7 วันล่าสุดเทียบ 7 วันก่อนหน้า)
function computeWeeklySummaryFromSheet_(sumSh){
  const N = 7;
  const { thisSum, prevSum, count } = sumWithPrevDays_(sumSh, N);
  const text = `ใช้ไฟสัปดาห์นี้: ${makeThaiUnits_(thisSum, 2)} ${fmtPct_(thisSum, prevSum)} | แนะนำ: ปิดอุปกรณ์ที่ไม่ใช้`;
  return { ok:true, thisWh:thisSum, prevWh:prevSum, days:count, text };
}
// สรุปค่าใช้ไฟรายเดือน (30 วันล่าสุดเทียบ 30 วันก่อนหน้า)
function computeMonthlySummaryFromSheet_(sumSh){
  const N = 30;
  const { thisSum, prevSum, count } = sumWithPrevDays_(sumSh, N);
  const text = `ใช้ไฟเดือนนี้: ${makeThaiUnits_(thisSum, 2)} ${fmtPct_(thisSum, prevSum)} | แนะนำ: ตั้งเวลาปิดอัตโนมัติ`;
  return { ok:true, thisWh:thisSum, prevWh:prevSum, days:count, text };
}

/************* Latest pull (robust, lookback) *************/
// ดึงสถานะล่าสุดแบบทนทาน: มองย้อน LOOKBACK แถว เพื่อเลือกค่า d/w/m ที่ไม่ศูนย์ (หรือ prev ล่าสุด)
function latestFromData_(sh){
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return null;

  const lastCol  = sh.getLastColumn();
  const LOOKBACK = Math.min(2000, lastRow - 1); // ~1.5 วัน (หากส่งทุกนาที)
  const startRow = lastRow - LOOKBACK + 1;
  const rows     = sh.getRange(startRow, 1, LOOKBACK, lastCol).getValues();

  let lastPrevD = 0, lastPrevW = 0, lastPrevM = 0;

  for (let i = rows.length - 1; i >= 0; i--) {
    const row = rows[i];
    const ts            = row[0];
    const dailyWh       = Number(row[15] || 0);
    const weeklyWh      = Number(row[16] || 0);
    const dailyWhPrev   = Number(row[17] || 0);
    const weeklyWhPrev  = Number(row[18] || 0);
    const monthWh       = Number(row[19] || 0);
    const monthWhPrev   = Number(row[20] || 0);

    // จดจำ prev ล่าสุดเพื่อใช้สำรองเมื่อค่าปัจจุบันเป็น 0
    if (dailyWhPrev  > 0 && lastPrevD === 0) lastPrevD = dailyWhPrev;
    if (weeklyWhPrev > 0 && lastPrevW === 0) lastPrevW = weeklyWhPrev;
    if (monthWhPrev  > 0 && lastPrevM === 0) lastPrevM = monthWhPrev;

    // เลือกค่าที่ "มีความหมาย" (ถ้าค่าปัจจุบันเป็น 0 ให้ fallback ไป prev)
    const effDaily   = dailyWh  > 0 ? dailyWh  : (dailyWhPrev  > 0 ? dailyWhPrev  : 0);
    const effWeekly  = weeklyWh > 0 ? weeklyWh : (weeklyWhPrev > 0 ? weeklyWhPrev : 0);
    const effMonthly = monthWh  > 0 ? monthWh  : (monthWhPrev  > 0 ? monthWhPrev  : 0);

    // พบค่าใดค่าหนึ่งที่ใช้ได้ → จัดรูป ISO เวลาและคืนผล
    if (effDaily > 0 || effWeekly > 0 || effMonthly > 0 ||
        dailyWhPrev > 0 || weeklyWhPrev > 0 || monthWhPrev > 0) {

      const tsISO = (ts instanceof Date)
        ? Utilities.formatDate(ts, TZ, "yyyy-MM-dd'T'HH:mm:ss")
        : String(ts);

      return {
        ok: true,
        tsISO: tsISO,
        dWh: effDaily,
        wWh: effWeekly,
        mWh: effMonthly,
        dWhPrev: (dailyWhPrev  > 0 ? dailyWhPrev  : lastPrevD) || 0,
        wWhPrev: (weeklyWhPrev > 0 ? weeklyWhPrev : lastPrevW) || 0,
        mWhPrev: (monthWhPrev  > 0 ? monthWhPrev  : lastPrevM) || 0
      };
    }
  }
  return { ok:false, reason:'NO_MEANINGFUL_DATA' };
}

/************* Utils *************/
// แปลงเป็น Number เมื่อมีค่า; ถ้าเป็นค่าว่าง/undefined ให้คงเป็น '' (กัน NaN ในชีต)
function num_(x){ return (x === '' || x === null || x === undefined) ? '' : Number(x); }
// true/false แบบยืดหยุ่น (รองรับ true/1/'1'/'true'/'เปิด'/'ตัดแล้ว')
function isTrue_(v){ return v===true || v===1 || v==='1' || String(v).toLowerCase()==='true' || v==='เปิด' || v==='ตัดแล้ว'; }
// แปลงเป็น 'เปิด'/'ปิด' เพื่อบันทึกในชีตให้อ่านง่าย
function onoff_(v){ return isTrue_(v) ? 'เปิด' : 'ปิด'; }
// แปลงสถานะ trip เป็นข้อความภาษาไทย
function tripText_(v){ return isTrue_(v) ? 'ตัดแล้ว' : 'ปกติ'; }
// ตัว parser แบบ plain: รองรับ CSV 21 ฟิลด์ (ชุดเต็ม) หรือรูป a=b&c=d (และบรรทัดใหม่)
function parsePlain_(raw){
  // รองรับทั้ง a=b&c=d และ CSV 'a,b,c,...' (ถ้าจำนวนฟิลด์ >= 21 คือชุดเต็ม)
  const res = {};
  const parts = raw.split(/[,|]/).map(s => s.trim());
  if (parts.length >= 21){
    [res.swA,res.swB,res.iIn,res.vIn,res.vA,res.vB,res.iA,res.iB,res.pA,res.pB,res.tC,res.hum,res.tripA,res.tripB,
     res.dWh,res.wWh,res.dWhPrev,res.wWhPrev,res.mWh,res.mWhPrev,res.peakdailyWh] = parts;
    return res;
  }
  raw.split(/[\n&]+/).forEach(seg=>{
    if (!seg) return;
    const i = seg.indexOf('=');
    if (i >= 0){
      const k = seg.slice(0,i).trim();
      const v = seg.slice(i+1).trim();
      if (k) res[k] = v;
    } else {
      const k = seg.trim();
      if (k) res[k] = '';
    }
  });
  return res;
}
// แปลงค่าจากเซลล์ (Date หรือ string) → รูป 'yyyy-MM-dd' ตาม TZ
function cellToYmd_(v){
  if (v instanceof Date) return Utilities.formatDate(v, TZ, 'yyyy-MM-dd');
  const s = String(v||'').trim();
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  const d = new Date(s); if (!isNaN(d.getTime())) return Utilities.formatDate(d, TZ, 'yyyy-MM-dd');
  return s;
}
// ค้นหาแถวของวัน ymd ในชีต Summary (เพื่ออัปเดตทับ ถ้ามีอยู่แล้ว)
function getSummaryRowIndex_(sh, ymd, map){
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return 0;
  const col = map.ts || 1;
  const vals = sh.getRange(2, col, lastRow-1, 1).getValues();
  for (let i=0;i<vals.length;i++){
    if (cellToYmd_(vals[i][0]) === ymd) return 2+i;
  }
  return 0;
}
// เขียนบรรทัด Log (เวลา, เมธอด, ป้าย tag, และรายละเอียด)
function log_(sh, method, tag, info1, info2){
  try{ sh.appendRow([new Date(), method, tag, (info2? (String(info1)+' | '+String(info2)) : String(info1)) ]); }catch(_){}
}
// ตัวช่วยส่งข้อความธรรมดา
function txt_(s){ return ContentService.createTextOutput(String(s)); }
// ตัวช่วยส่ง JSON (ตั้ง MIME เป็น application/json)
function json_(o){ return ContentService.createTextOutput(JSON.stringify(o)).setMimeType(ContentService.MimeType.JSON); }
